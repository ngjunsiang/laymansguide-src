<!DOCTYPE html>
<html lang="en">
<head>
        <title>Layman's Guide to Computing - cpu tag</title>
        <meta charset="utf-8" />
        <meta name="generator" content="Pelican" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="/theme/css/style.css" />
</head>

<body>
        <header>
              <hgroup><h1><a href="/">Layman's Guide to Computing</a></h1></hgroup>
        <nav><ul>
            <li><a href="/categories">Seasons</a></li>
            <li><a href="/tags">Tags</a></li>
        </ul></nav>
        </header>
        <main>
<h2>Articles tagged with cpu</h2>


        <article>
                <header> <h2><a href="/issue053.html" rel="bookmark" title="Permalink to Issue 53: The CPU is an instruction-obeying slave">Issue 53: The CPU is an instruction-obeying slave</a></h2> </header>
                <section><p>CPUs are unconscious slaves that simply execute instruction after instruction, at a very fast rate.</p></section>
                <footer>
                    <p>Published: <time datetime="2019-12-28T08:00:00+08:00"> Sat 28 December 2019 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue054.html" rel="bookmark" title="Permalink to Issue 54: Compiling programming code into CPU instructions">Issue 54: Compiling programming code into CPU instructions</a></h2> </header>
                <section><p>To get useful output from a CPU, we must translate the operations we want it to perform into CPU instructions, in a process known as <strong>compiling</strong>. Most compilers convert programming code into CPU instructions.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-01-04T08:00:00+08:00"> Sat 04 January 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue055.html" rel="bookmark" title="Permalink to Issue 55: Addressing memory">Issue 55: Addressing memory</a></h2> </header>
                <section><p>The life of the unconscious CPU is just executing instruction after instruction after instruction. Each instruction may consist of loading data from a memory location, sending data to a memory location, or performing operations on the data it is holding.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-01-11T08:00:00+08:00"> Sat 11 January 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue057.html" rel="bookmark" title="Permalink to Issue 57: Cache, the CPU’s working space">Issue 57: Cache, the CPU’s working space</a></h2> </header>
                <section><p>The CPU stores data for ready access in the CPU cache. Accessing data from the CPU cache is much faster than accessing data from memory. When the CPU needs data from a memory address, it looks in the cache first. If the data is not there (a <strong>cache miss</strong>), it will load the data from the memory address, and store a copy in the cache for faster reference in future. The CPU cache is managed by the CPU and is invisible to the OS. Programs that need to ensure the data in the cache is “fresh” can perform a cache flush and reload.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-01-25T08:00:00+08:00"> Sat 25 January 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue058.html" rel="bookmark" title="Permalink to Issue 58: CPU Optimisation Part 1 – Out-of-Order Processing">Issue 58: CPU Optimisation Part 1 – Out-of-Order Processing</a></h2> </header>
                <section><p>The CPU comprises different types of execution units. All the execution units can run at the same time, but they may execute instructions over different numbers of clock cycles. To minimise wait time, CPU instructions are carried out in an order that keeps the execution units busy as often as possible.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-02-01T08:00:00+08:00"> Sat 01 February 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue059.html" rel="bookmark" title="Permalink to Issue 59: Meltdown">Issue 59: Meltdown</a></h2> </header>
                <section><p>A set of instructions can trick a CPU into reordering load instructions so that the data is temporarily loaded into the cache before the instructions are retired. The cache can then be snooped to retrieve the data.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-02-08T08:00:00+08:00"> Sat 08 February 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue060.html" rel="bookmark" title="Permalink to Issue 60: CPU Optimisation Part 2 – Speculative Execution and Spectre">Issue 60: CPU Optimisation Part 2 – Speculative Execution and Spectre</a></h2> </header>
                <section><p>Speculative execution is a feature that let’s the CPU speed up execution if it correctly predicts a decision point. The CPU carries out the operations along the predicted decision branch and loads the results if it predicts correctly.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-02-15T08:00:00+08:00"> Sat 15 February 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue061.html" rel="bookmark" title="Permalink to Issue 61: Mapping the cache">Issue 61: Mapping the cache</a></h2> </header>
                <section><p>A cache miss is slow, and a cache hit is fast. This difference in cache reading speed can be used to transmit secrets out from the cache, which cannot be read directly by programs.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-02-22T08:00:00+08:00"> Sat 22 February 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue062.html" rel="bookmark" title="Permalink to Issue 62: Cache snooping">Issue 62: Cache snooping</a></h2> </header>
                <section></section>
                <footer>
                    <p>Published: <time datetime="2020-03-03T17:00:00+08:00"> Tue 03 March 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue064.html" rel="bookmark" title="Permalink to Issue 64: Fixing Meltdown and Spectre">Issue 64: Fixing Meltdown and Spectre</a></h2> </header>
                <section><p>Meltdown and Spectre require the programs executing them to have access to kernel memory space. Kernel address isolation attempts to prevent the program from even having access to the kernel address space in the first place. TLB flushing changes the virtual-to-physical memory mapping, disrupting Spectre’s reliance on a consistent virtual-to-physical memory mapping.</p></section>
                <footer>
                    <p>Published: <time datetime="2020-03-14T08:00:00+08:00"> Sat 14 March 2020 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>
        <article>
                <header> <h2><a href="/issue117.html" rel="bookmark" title="Permalink to Issue 117: Swap space">Issue 117: Swap space</a></h2> </header>
                <section><p>Operating systems use a page file on the storage disk as a complement to physical memory. This allows OSes to behave more performantly than they would if they did not have a page file. Data that is rarely accessed is moved to the pagefile (“paged out”), and can be paged in when it is needed later, albeit with a performance hit.</p></section>
                <footer>
                    <p>Published: <time datetime="2021-04-24T08:00:00+08:00"> Sat 24 April 2021 </time></p>
                    <address>By
                        <a href="/author/j-s-ng.html">J S Ng</a>
                    </address>
                </footer>
        </article>


        </main>
        <footer>
                <address>
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>,
                which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address>
        </footer>
</body>
</html>